#!/bin/bash

# Configuration
LLM_CMD="gemini" # Default to gemini
LLM_ARGS=""
PROMPTS_DIR="cli/prompts"
REGISTER_FILE="register.md"
DOMAINS_DIR="domains"
LESSONS_DIR="lessons"
ANSWERS_DIR="outputs/answers"

# Parse global options (before command)
while [[ $# -gt 0 && "$1" == --* ]]; do
    case "$1" in
        --claude)
            LLM_CMD="claude"
            LLM_ARGS="--print --output-format text --allowedTools WebSearch,WebFetch"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check if LLM CLI is available
if ! command -v "$LLM_CMD" &> /dev/null; then
    echo "Error: $LLM_CMD cli not found. Please install it or update the script."
    exit 1
fi

COMMAND=$1
shift
# Remaining arguments are in "$@"

case $COMMAND in
  capture)
    AUTO_MERGE=0
    INPUT_ARGS=""
    
    # Parse args for this command
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --auto-merge|-a)
          AUTO_MERGE=1
          shift
          ;;
        *)
          if [ -n "$INPUT_ARGS" ]; then
            INPUT_ARGS="$INPUT_ARGS $1"
          else
            INPUT_ARGS="$1"
          fi
          shift
          ;;
      esac
    done
    
    USER_INPUT="$INPUT_ARGS"

    if [ -z "$USER_INPUT" ]; then
      echo "Usage: $0 capture [--auto-merge/-a] <note content | url | file path>"
      exit 1
    fi
    
    # Determine input type
    if [[ "$USER_INPUT" =~ ^https?:// ]]; then
      echo "Fetching URL content..."
      RAW_CONTENT=$(curl -sL "$USER_INPUT")
      if [ -z "$RAW_CONTENT" ]; then
        echo "Error: Failed to fetch URL or empty response."
        exit 1
      fi
      SOURCE_TYPE="URL: $USER_INPUT"
    elif [[ "$USER_INPUT" =~ \.[pP][dD][fF]$ ]]; then
      echo "Error: PDF files cannot be processed directly. Please convert to text first."
      exit 1
    elif [ -f "$USER_INPUT" ]; then
      # Check if it's a URL list (first line starts with http)
      FIRST_LINE=$(head -n 1 "$USER_INPUT")
      if [[ "$FIRST_LINE" =~ ^https?:// ]]; then
          echo "Detected Batch URL List..."
          SOURCE_TYPE="Batch URL List: $USER_INPUT"
          RAW_CONTENT=""
          
          while IFS= read -r url || [ -n "$url" ]; do
              # Skip empty lines
              if [ -z "$url" ]; then continue; fi
              
              echo "  Fetching: $url"
              FETCHED=$(curl -sL "$url")
              if [ -n "$FETCHED" ]; then
                  RAW_CONTENT+=$'\n'"--- Source: $url ---"$'\n'"$FETCHED"$'\n'
              else
                  echo "  Warning: Failed to fetch $url"
              fi
          done < "$USER_INPUT"
          
          if [ -z "$RAW_CONTENT" ]; then
              echo "Error: No content fetched from batch list."
              exit 1
          fi
      else
          echo "Reading file..."
          RAW_CONTENT=$(cat "$USER_INPUT")
          SOURCE_TYPE="File: $USER_INPUT"
      fi
    else
      RAW_CONTENT="$USER_INPUT"
      SOURCE_TYPE="User Input"
    fi

    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/capture.md")
    
    # We use a temp file to safely construct the prompt with potentially large content
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Source Context: $SOURCE_TYPE" >> "$TMP_PROMPT"
    echo "User Input:" >> "$TMP_PROMPT"
    echo "$RAW_CONTENT" >> "$TMP_PROMPT"
    
    echo "Processing note..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    if [ $? -eq 0 ]; then
      echo "" >> "$REGISTER_FILE"
      echo "$RESPONSE" >> "$REGISTER_FILE"
      echo "------------------------------------------------"
      echo "$RESPONSE"
      echo "------------------------------------------------"
      echo "Note added to $REGISTER_FILE"
      
      if [ "$AUTO_MERGE" -eq 1 ]; then
        echo "================================================"
        echo "ðŸ”„ Auto-Merge Triggered"
        echo "================================================"
        
        # Run classify
        "$0" classify
        
        # Find the latest pending merge file
        # We look for the most recent .md file in the pending directory
        LATEST_MERGE=$(ls -t outputs/merges/pending/*.md 2>/dev/null | head -n 1)
        
        if [ -n "$LATEST_MERGE" ]; then
            FILENAME=$(basename "$LATEST_MERGE")
            echo "Merging proposal: $FILENAME"
            "$0" merge "$FILENAME"
        else
            echo "Error: Could not find generated merge proposal."
        fi
      fi
    else
      echo "Error calling LLM."
    fi
    ;;

  learn)
    USER_INPUT="$@"
    if [ -z "$USER_INPUT" ]; then
      echo "Usage: $0 learn <correction or insight>"
      exit 1
    fi
    
    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/learn.md")
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Input:" >> "$TMP_PROMPT"
    echo "$USER_INPUT" >> "$TMP_PROMPT"
    
    echo "Processing lesson..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    TIMESTAMP=$(date +%Y%m%d%H%M%S)
    LESSON_FILE="$LESSONS_DIR/answers/L-$TIMESTAMP.md"
    mkdir -p "$LESSONS_DIR/answers"
    
    echo "$RESPONSE" > "$LESSON_FILE"
    
    echo "------------------------------------------------"
    cat "$LESSON_FILE"
    echo "------------------------------------------------"
    echo "Lesson saved to $LESSON_FILE"
    ;;

  classify)
    USER_INPUT="$@"
    # Setup directories
    MERGES_DIR="outputs/merges/pending"
    ARCHIVE_DIR="outputs/register_archive"
    mkdir -p "$MERGES_DIR" "$ARCHIVE_DIR"

    # If input is provided, classify that directly (do not archive register)
    if [ -n "$USER_INPUT" ]; then
      NOTE_CONTENT="$USER_INPUT"
      SOURCE_REF="manual_input"
    else
      # Process register.md
      if [ -f "$REGISTER_FILE" ] && [ -s "$REGISTER_FILE" ]; then
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        ARCHIVED_REGISTER="$ARCHIVE_DIR/register_$TIMESTAMP.md"
        
        # Archive the current register
        mv "$REGISTER_FILE" "$ARCHIVED_REGISTER"
        touch "$REGISTER_FILE"
        echo "Archived $REGISTER_FILE to $ARCHIVED_REGISTER"
        
        NOTE_CONTENT=$(cat "$ARCHIVED_REGISTER")
        SOURCE_REF="register_$TIMESTAMP"
      else
        echo "Error: No input provided and $REGISTER_FILE is empty or missing."
        exit 1
      fi
    fi

    # Build Domain Map
    echo "Building Domain Map..."
    DOMAIN_MAP=$(find "$DOMAINS_DIR" -name "index.md" -print0 | xargs -0 -I {} sh -c 'echo "--- File: {} ---"; cat {}; echo ""')

    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/classify.md")
    
    # Construct prompt via concatenation
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "DOMAIN MAP:" >> "$TMP_PROMPT"
    echo "$DOMAIN_MAP" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Input Note from Register:" >> "$TMP_PROMPT"
    echo "$NOTE_CONTENT" >> "$TMP_PROMPT"
    
    echo "Classifying content..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    # Save to pending
    TIMESTAMP=$(date +%Y%m%d%H%M%S)
    MERGE_FILE="$MERGES_DIR/merge_${TIMESTAMP}.md"
    
    echo "$RESPONSE" > "$MERGE_FILE"
    
    if [ -f "$MERGE_FILE" ]; then
        echo "------------------------------------------------"
        cat "$MERGE_FILE"
        echo "------------------------------------------------"
        echo "Merge proposal created: $MERGE_FILE"
        echo "Status: PENDING"
        echo "To approve, move content to domains and run: $0 merge $(basename $MERGE_FILE)"
    else
        echo "Error writing merge file."
    fi
    ;;

  merge)
    if [[ "$1" == "--all" || "$1" == "-a" ]]; then
      PENDING_DIR="outputs/merges/pending"
      if [ ! -d "$PENDING_DIR" ] || [ -z "$(ls -A "$PENDING_DIR")" ]; then
        echo "No pending merges found."
        exit 0
      fi
      
      echo "Merging all pending proposals..."
      for file in "$PENDING_DIR"/*.md; do
        if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo ">> Processing $filename"
            "$0" merge "$filename"
        fi
      done
      exit 0
    fi

    FILENAME="$1"
    PENDING_DIR="outputs/merges/pending"
    PROCESSED_DIR="outputs/merges/processed"
    mkdir -p "$PROCESSED_DIR"
    
    if [ -z "$FILENAME" ]; then
      echo "Usage: $0 merge <filename>"
      echo "Available pending merges:"
      ls "$PENDING_DIR"
      exit 1
    fi
    
    BASENAME=$(basename "$FILENAME")
    SOURCE_FILE="$PENDING_DIR/$BASENAME"
    
    if [ ! -f "$SOURCE_FILE" ]; then
      echo "Error: File $SOURCE_FILE not found."
      exit 1
    fi
    
    # Create temp dir for splitting
    SPLIT_DIR=$(mktemp -d)
    
    # Split the file into individual entries
    # We use awk to write to separate files prefixed with split_ in the temp dir
    awk -v out="$SPLIT_DIR/split_" '/^## Entry ID/{n++} {print > (out n ".md")}' "$SOURCE_FILE"
    
    # Check if any files were created
    if [ -z "$(ls -A "$SPLIT_DIR")" ]; then
       echo "Error: No valid entries found in $SOURCE_FILE (missing '## Entry ID' header?)"
       rm -rf "$SPLIT_DIR"
       exit 1
    fi
    
    # Loop through each split entry
    for ENTRY_FILE in "$SPLIT_DIR"/*.md; do
        echo "Processing entry: $(basename "$ENTRY_FILE")..."
        
        # Extract Target File and clean it
        RAW_TARGET=$(grep "Target File:" "$ENTRY_FILE" | head -n 1 | cut -d ':' -f 2)
        TARGET_FILE=$(echo "$RAW_TARGET" | sed 's/ (New)//g' | sed 's/ (Existing)//g' | xargs)
        
        if [ -z "$TARGET_FILE" ]; then
          echo "  Warning: Could not parse 'Target File' from entry. Skipping."
          continue
        fi
        
        # Check if we need to create a new file
        if [ ! -f "$TARGET_FILE" ]; then
            echo "  Creating new file: $TARGET_FILE"
            mkdir -p "$(dirname "$TARGET_FILE")"
            touch "$TARGET_FILE"
            
            # Extract Index Update
            INDEX_UPDATE=$(awk '/### Index Update/{flag=1; next} /### Conflicts Detected/{flag=0} flag' "$ENTRY_FILE")
            
            if [ -n "$INDEX_UPDATE" ]; then
                PARENT_DIR=$(dirname "$TARGET_FILE")
                INDEX_FILE="$PARENT_DIR/index.md"
                
                if [ -f "$INDEX_FILE" ]; then
                    echo "  Updating index: $INDEX_FILE"
                    TMP_INDEX=$(mktemp)
                    while IFS= read -r line; do
                        echo "$line" >> "$TMP_INDEX"
                        if [[ "$line" == "## Active Topics" ]]; then
                            echo "$INDEX_UPDATE" >> "$TMP_INDEX"
                        fi
                    done < "$INDEX_FILE"
                    mv "$TMP_INDEX" "$INDEX_FILE"
                else
                    echo "  Warning: Parent index $INDEX_FILE not found. Skipping index update."
                fi
            fi
        fi
        
        # Extract content to merge
        CONTENT_TO_MERGE=$(awk '/### Proposed Insert/{flag=1; next} /### Index Update/{flag=0} /### Conflicts Detected/{flag=0} flag' "$ENTRY_FILE")
        
        if [ -z "$CONTENT_TO_MERGE" ]; then
            echo "  Warning: No content found in 'Proposed Insert' section. Skipping."
            continue
        fi
        
        echo "  Merging content into $TARGET_FILE..."
        echo "" >> "$TARGET_FILE"
        echo "$CONTENT_TO_MERGE" >> "$TARGET_FILE"
    done
    
    # Cleanup temp dir
    rm -rf "$SPLIT_DIR"
    
    echo "Success. Moving proposal to processed."
    mv "$SOURCE_FILE" "$PROCESSED_DIR/"
    ;;

  approve)
    FILENAME="$1"
    PENDING_DIR="outputs/merges/pending"
    PROCESSED_DIR="outputs/merges/processed"
    mkdir -p "$PROCESSED_DIR"
    
    if [ -z "$FILENAME" ]; then
      echo "Usage: $0 approve <filename>"
      echo "Available pending merges:"
      ls "$PENDING_DIR"
      exit 1
    fi
    
    # Handle if user passed full path or just filename
    BASENAME=$(basename "$FILENAME")
    SOURCE_FILE="$PENDING_DIR/$BASENAME"
    
    if [ -f "$SOURCE_FILE" ]; then
      mv "$SOURCE_FILE" "$PROCESSED_DIR/"
      echo "Marked $BASENAME as PROCESSED."
    else
      echo "Error: File $SOURCE_FILE not found."
    fi
    ;;

  question)
    SAVE_MODE=0
    QUESTION_TEXT=""
    
    # Parse args for this command
    while [[ $# -gt 0 ]]; do
      key="$1"
      case $key in
        --save|-s)
          SAVE_MODE=1
          shift
          ;;
        *)
          QUESTION_TEXT="$QUESTION_TEXT $1"
          shift
          ;;
      esac
    done
    
    # Trim leading space
    QUESTION_TEXT=$(echo "$QUESTION_TEXT" | sed 's/^[[:space:]]*//')
    
    if [ -z "$QUESTION_TEXT" ]; then
      echo "Usage: $0 question [--save] <your question>"
      exit 1
    fi
    
    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/question.md")
    # Include both DOMAINS and LESSONS in the context
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Question:" >> "$TMP_PROMPT"
    echo "$QUESTION_TEXT" >> "$TMP_PROMPT"
    
    echo "Thinking..."
    TMP_OUTPUT=$(mktemp)
    cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS > "$TMP_OUTPUT" 2>&1
    RESPONSE=$(cat "$TMP_OUTPUT")
    rm "$TMP_PROMPT" "$TMP_OUTPUT"

    if [ "$SAVE_MODE" -eq 1 ]; then
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        mkdir -p "$ANSWERS_DIR"
        OUT_FILE="$ANSWERS_DIR/A-$TIMESTAMP.md"
        
        echo "# Answer Record: A-$TIMESTAMP" > "$OUT_FILE"
        echo "**Date:** $(date)" >> "$OUT_FILE"
        echo "**Question:** $QUESTION_TEXT" >> "$OUT_FILE"
        echo "" >> "$OUT_FILE"
        echo "## Answer" >> "$OUT_FILE"
        echo "$RESPONSE" >> "$OUT_FILE"
        
        echo "Answer saved to: $OUT_FILE"
        echo "------------------------------------------------"
        cat "$OUT_FILE"
        echo "------------------------------------------------"
    else
        echo "$RESPONSE"
    fi
    ;;
    
  refresh)
    FILENAME="$1"
    
    if [ -z "$FILENAME" ]; then
        echo "Usage: $0 refresh <answer_file>"
        exit 1
    fi
    
    if [ ! -f "$FILENAME" ]; then
        echo "Error: File $FILENAME not found."
        exit 1
    fi
    
    # Extract Original Question
    ORIGINAL_QUESTION=$(grep "\*\*Question:\*\*" "$FILENAME" | cut -d ':' -f 2- | xargs)
    
    if [ -z "$ORIGINAL_QUESTION" ]; then
        echo "Error: Could not extract question from $FILENAME."
        exit 1
    fi
    
    echo "Re-running question: $ORIGINAL_QUESTION"
    
    # Re-run LLM
    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/question.md")
    # Include LESSONS here too
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Question:" >> "$TMP_PROMPT"
    echo "$ORIGINAL_QUESTION" >> "$TMP_PROMPT"
    
    echo "Thinking..."
    NEW_RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    # Create temp file with new content for diffing
    TMP_NEW=$(mktemp)
    sed '/## Answer/q' "$FILENAME" > "$TMP_NEW"
    echo "$NEW_RESPONSE" >> "$TMP_NEW"
    
    echo "Diff (Original vs New):"
    echo "------------------------------------------------"
    diff "$FILENAME" "$TMP_NEW"
    echo "------------------------------------------------"
    
    read -p "Accept new version? (y/n): " CONFIRM
    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
        mv "$TMP_NEW" "$FILENAME"
        echo "Updated $FILENAME."
    else
        echo "Kept original version."
        rm "$TMP_NEW"
    fi
    ;;

  garden)
    echo "================================================"
    echo "ðŸŒ¿ Knowledge Garden Audit"
    echo "================================================"
    
    echo ""
    echo "ðŸ‚ Stale Files (>60 days since update):"
    STALE_FILES=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -mtime +60 2>/dev/null)
    if [ -z "$STALE_FILES" ]; then
        echo "   (None - Good job!)"
    else
        echo "$STALE_FILES"
    fi

    echo ""
    echo "ðŸ•¸ï¸  Empty Files (0 bytes):"
    EMPTY_FILES=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -type f -empty 2>/dev/null)
    if [ -z "$EMPTY_FILES" ]; then
        echo "   (None)"
    else
        echo "$EMPTY_FILES"
    fi
    
    echo ""
    echo "ðŸ‘» Orphaned Files (Not referenced in parent index):"
    # Logic: Find leaf files, check if filename exists in parent index.md
    find "$DOMAINS_DIR" -name "*.md" ! -name "index.md" -print0 | while IFS= read -r -d '' file; do
        dir=$(dirname "$file")
        filename=$(basename "$file")
        index_file="$dir/index.md"
        
        # If index exists, check content
        if [ -f "$index_file" ]; then
            if ! grep -q "$filename" "$index_file"; then
                echo "   $file (missing from $(basename "$dir")/index.md)"
            fi
        fi
    done
    echo "================================================"
    ;;

  challenge)
    USER_INPUT="$@"
    if [ -z "$USER_INPUT" ]; then
      echo "Usage: $0 challenge <proposal text | file path>"
      exit 1
    fi
    
    # Determine input type
    if [ -f "$USER_INPUT" ]; then
      echo "Reading proposal file..."
      PROPOSAL_CONTENT=$(cat "$USER_INPUT")
    else
      PROPOSAL_CONTENT="$USER_INPUT"
    fi

    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/challenge.md")
    # Gather broad context
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context (Knowledge Base):" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Proposal:" >> "$TMP_PROMPT"
    echo "$PROPOSAL_CONTENT" >> "$TMP_PROMPT"
    
    echo "âš”ï¸  Challenging your proposal..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    echo "------------------------------------------------"
    echo "$RESPONSE"
    echo "------------------------------------------------"
    ;;

  *)
    echo "Usage: $0 [--claude] {capture|classify|question|learn|refresh|garden|challenge} [arguments]"
    echo "Options:"
    echo "  --claude    Use Claude instead of Gemini (default), with web search enabled"
    exit 1
    ;;
esac