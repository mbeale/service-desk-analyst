#!/bin/bash

# Configuration
LLM_CMD="gemini" # Default to gemini
LLM_ARGS=""
PROMPTS_DIR="cli/prompts"
REGISTER_FILE="register.md"
DOMAINS_DIR="domains"
LESSONS_DIR="lessons"
ANSWERS_DIR="outputs/answers"

# Parse global options (before command)
while [[ $# -gt 0 && "$1" == --* ]]; do
    case "$1" in
        --claude)
            LLM_CMD="claude"
            LLM_ARGS="--print --output-format text --allowedTools WebSearch,WebFetch"
            shift
            ;;
        --kilo|--kilocode)
            LLM_CMD="kilocode"
            LLM_ARGS="--auto --nosplash"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check if LLM CLI is available
if ! command -v "$LLM_CMD" &> /dev/null; then
    echo "Error: $LLM_CMD cli not found. Please install it or update the script."
    exit 1
fi

COMMAND=$1
shift
# Remaining arguments are in "$@"

case $COMMAND in
  capture)
    AUTO_MERGE=0
    INPUT_ARGS=""
    
    # Parse args for this command
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --auto-merge|-a)
          AUTO_MERGE=1
          shift
          ;;
        *)
          if [ -n "$INPUT_ARGS" ]; then
            INPUT_ARGS="$INPUT_ARGS $1"
          else
            INPUT_ARGS="$1"
          fi
          shift
          ;;
      esac
    done
    
    USER_INPUT="$INPUT_ARGS"

    if [ -z "$USER_INPUT" ]; then
      echo "Usage: $0 capture [--auto-merge/-a] <note content | url | file path>"
      exit 1
    fi
    
    # Determine input type
    if [[ "$USER_INPUT" =~ ^https?:// ]]; then
      echo "Fetching URL content..."
      RAW_CONTENT=$(curl -sL "$USER_INPUT")
      if [ -z "$RAW_CONTENT" ]; then
        echo "Error: Failed to fetch URL or empty response."
        exit 1
      fi
      SOURCE_TYPE="URL: $USER_INPUT"
    elif [[ "$USER_INPUT" =~ \.[pP][dD][fF]$ ]]; then
      echo "Error: PDF files cannot be processed directly. Please convert to text first."
      exit 1
    elif [ -f "$USER_INPUT" ]; then
      # Check if it's a URL list (first line starts with http)
      FIRST_LINE=$(head -n 1 "$USER_INPUT")
      if [[ "$FIRST_LINE" =~ ^https?:// ]]; then
          echo "Detected Batch URL List..."
          SOURCE_TYPE="Batch URL List: $USER_INPUT"
          RAW_CONTENT=""
          
          while IFS= read -r url || [ -n "$url" ]; do
              # Skip empty lines
              if [ -z "$url" ]; then continue; fi
              
              echo "  Fetching: $url"
              FETCHED=$(curl -sL "$url")
              if [ -n "$FETCHED" ]; then
                  RAW_CONTENT+=$'\n'"--- Source: $url ---"$'\n'"$FETCHED"$'\n'
              else
                  echo "  Warning: Failed to fetch $url"
              fi
          done < "$USER_INPUT"
          
          if [ -z "$RAW_CONTENT" ]; then
              echo "Error: No content fetched from batch list."
              exit 1
          fi
      else
          echo "Reading file..."
          RAW_CONTENT=$(cat "$USER_INPUT")
          SOURCE_TYPE="File: $USER_INPUT"
      fi
    else
      RAW_CONTENT="$USER_INPUT"
      SOURCE_TYPE="User Input"
    fi

    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/capture.md")
    
    # We use a temp file to safely construct the prompt with potentially large content
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Source Context: $SOURCE_TYPE" >> "$TMP_PROMPT"
    echo "User Input:" >> "$TMP_PROMPT"
    echo "$RAW_CONTENT" >> "$TMP_PROMPT"
    
    echo "Processing note..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    if [ $? -eq 0 ]; then
      echo "" >> "$REGISTER_FILE"
      echo "$RESPONSE" >> "$REGISTER_FILE"
      echo "------------------------------------------------"
      echo "$RESPONSE"
      echo "------------------------------------------------"
      echo "Note added to $REGISTER_FILE"
      
      if [ "$AUTO_MERGE" -eq 1 ]; then
        echo "================================================"
        echo "ðŸ”„ Auto-Merge Triggered"
        echo "================================================"
        
        # Run classify
        "$0" classify
        
        # Find the latest pending merge file
        # We look for the most recent .md file in the pending directory
        LATEST_MERGE=$(ls -t outputs/merges/pending/*.md 2>/dev/null | head -n 1)
        
        if [ -n "$LATEST_MERGE" ]; then
            FILENAME=$(basename "$LATEST_MERGE")
            echo "Merging proposal: $FILENAME"
            "$0" merge "$FILENAME"
        else
            echo "Error: Could not find generated merge proposal."
        fi
      fi
    else
      echo "Error calling LLM."
    fi
    ;;

  learn)
    USER_INPUT="$@"
    if [ -z "$USER_INPUT" ]; then
      echo "Usage: $0 learn <correction or insight>"
      exit 1
    fi
    
    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/learn.md")
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Input:" >> "$TMP_PROMPT"
    echo "$USER_INPUT" >> "$TMP_PROMPT"
    
    echo "Processing lesson..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    TIMESTAMP=$(date +%Y%m%d%H%M%S)
    LESSON_FILE="$LESSONS_DIR/answers/L-$TIMESTAMP.md"
    mkdir -p "$LESSONS_DIR/answers"
    
    echo "$RESPONSE" > "$LESSON_FILE"
    
    echo "------------------------------------------------"
    cat "$LESSON_FILE"
    echo "------------------------------------------------"
    echo "Lesson saved to $LESSON_FILE"
    ;;

  classify)
    USER_INPUT="$@"
    # Setup directories
    MERGES_DIR="outputs/merges/pending"
    ARCHIVE_DIR="outputs/register_archive"
    mkdir -p "$MERGES_DIR" "$ARCHIVE_DIR"

    # If input is provided, classify that directly (do not archive register)
    if [ -n "$USER_INPUT" ]; then
      NOTE_CONTENT="$USER_INPUT"
      SOURCE_REF="manual_input"
    else
      # Process register.md
      if [ -f "$REGISTER_FILE" ] && [ -s "$REGISTER_FILE" ]; then
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        ARCHIVED_REGISTER="$ARCHIVE_DIR/register_$TIMESTAMP.md"
        
        # Archive the current register
        mv "$REGISTER_FILE" "$ARCHIVED_REGISTER"
        touch "$REGISTER_FILE"
        echo "Archived $REGISTER_FILE to $ARCHIVED_REGISTER"
        
        NOTE_CONTENT=$(cat "$ARCHIVED_REGISTER")
        SOURCE_REF="register_$TIMESTAMP"
      else
        echo "Error: No input provided and $REGISTER_FILE is empty or missing."
        exit 1
      fi
    fi

    # Build Domain Map
    echo "Building Domain Map..."
    DOMAIN_MAP=$(find "$DOMAINS_DIR" -name "index.md" -print0 | xargs -0 -I {} sh -c 'echo "--- File: {} ---"; cat {}; echo ""')

    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/classify.md")
    
    # Construct prompt via concatenation
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "DOMAIN MAP:" >> "$TMP_PROMPT"
    echo "$DOMAIN_MAP" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Input Note from Register:" >> "$TMP_PROMPT"
    echo "$NOTE_CONTENT" >> "$TMP_PROMPT"
    
    echo "Classifying content..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    # Save to pending
    TIMESTAMP=$(date +%Y%m%d%H%M%S)
    MERGE_FILE="$MERGES_DIR/merge_${TIMESTAMP}.md"
    
    echo "$RESPONSE" > "$MERGE_FILE"
    
    if [ -f "$MERGE_FILE" ]; then
        echo "------------------------------------------------"
        cat "$MERGE_FILE"
        echo "------------------------------------------------"
        echo "Merge proposal created: $MERGE_FILE"
        echo "Status: PENDING"
        echo "To approve, move content to domains and run: $0 merge $(basename $MERGE_FILE)"
    else
        echo "Error writing merge file."
    fi
    ;;

  merge)
    if [[ "$1" == "--all" || "$1" == "-a" ]]; then
      PENDING_DIR="outputs/merges/pending"
      if [ ! -d "$PENDING_DIR" ] || [ -z "$(ls -A "$PENDING_DIR")" ]; then
        echo "No pending merges found."
        exit 0
      fi
      
      echo "Merging all pending proposals..."
      for file in "$PENDING_DIR"/*.md; do
        if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo ">> Processing $filename"
            "$0" merge "$filename"
        fi
      done
      exit 0
    fi

    FILENAME="$1"
    PENDING_DIR="outputs/merges/pending"
    PROCESSED_DIR="outputs/merges/processed"
    mkdir -p "$PROCESSED_DIR"
    
    if [ -z "$FILENAME" ]; then
      echo "Usage: $0 merge <filename>"
      echo "Available pending merges:"
      ls "$PENDING_DIR"
      exit 1
    fi
    
    BASENAME=$(basename "$FILENAME")
    SOURCE_FILE="$PENDING_DIR/$BASENAME"
    
    if [ ! -f "$SOURCE_FILE" ]; then
      echo "Error: File $SOURCE_FILE not found."
      exit 1
    fi
    
    # Create temp dir for splitting
    SPLIT_DIR=$(mktemp -d)
    
    # Split the file into individual entries
    # We use awk to write to separate files prefixed with split_ in the temp dir
    awk -v out="$SPLIT_DIR/split_" '/^## Entry ID/{n++} {print > (out n ".md")}' "$SOURCE_FILE"
    
    # Check if any files were created
    if [ -z "$(ls -A "$SPLIT_DIR")" ]; then
       echo "Error: No valid entries found in $SOURCE_FILE (missing '## Entry ID' header?)"
       rm -rf "$SPLIT_DIR"
       exit 1
    fi
    
    # Loop through each split entry
    for ENTRY_FILE in "$SPLIT_DIR"/*.md; do
        echo "Processing entry: $(basename "$ENTRY_FILE")..."
        
        # Extract Target File and clean it
        RAW_TARGET=$(grep "Target File:" "$ENTRY_FILE" | head -n 1 | cut -d ':' -f 2)
        TARGET_FILE=$(echo "$RAW_TARGET" | sed 's/ (New)//g' | sed 's/ (Existing)//g' | xargs)
        
        if [ -z "$TARGET_FILE" ]; then
          echo "  Warning: Could not parse 'Target File' from entry. Skipping."
          continue
        fi
        
        # Check if we need to create a new file
        if [ ! -f "$TARGET_FILE" ]; then
            echo "  Creating new file: $TARGET_FILE"
            mkdir -p "$(dirname "$TARGET_FILE")"
            touch "$TARGET_FILE"
            
            # Extract Index Update
            INDEX_UPDATE=$(awk '/### Index Update/{flag=1; next} /### Conflicts Detected/{flag=0} flag' "$ENTRY_FILE")
            
            if [ -n "$INDEX_UPDATE" ]; then
                PARENT_DIR=$(dirname "$TARGET_FILE")
                INDEX_FILE="$PARENT_DIR/index.md"
                
                if [ -f "$INDEX_FILE" ]; then
                    echo "  Updating index: $INDEX_FILE"
                    TMP_INDEX=$(mktemp)
                    while IFS= read -r line; do
                        echo "$line" >> "$TMP_INDEX"
                        if [[ "$line" == "## Active Topics" ]]; then
                            echo "$INDEX_UPDATE" >> "$TMP_INDEX"
                        fi
                    done < "$INDEX_FILE"
                    mv "$TMP_INDEX" "$INDEX_FILE"
                else
                    echo "  Warning: Parent index $INDEX_FILE not found. Skipping index update."
                fi
            fi
        fi
        
        # Extract content to merge
        CONTENT_TO_MERGE=$(awk '/### Proposed Insert/{flag=1; next} /### Index Update/{flag=0} /### Conflicts Detected/{flag=0} flag' "$ENTRY_FILE")
        
        if [ -z "$CONTENT_TO_MERGE" ]; then
            echo "  Warning: No content found in 'Proposed Insert' section. Skipping."
            continue
        fi
        
        echo "  Merging content into $TARGET_FILE..."
        echo "" >> "$TARGET_FILE"
        echo "$CONTENT_TO_MERGE" >> "$TARGET_FILE"
    done
    
    # Cleanup temp dir
    rm -rf "$SPLIT_DIR"
    
    echo "Success. Moving proposal to processed."
    mv "$SOURCE_FILE" "$PROCESSED_DIR/"
    ;;

  approve)
    FILENAME="$1"
    PENDING_DIR="outputs/merges/pending"
    PROCESSED_DIR="outputs/merges/processed"
    mkdir -p "$PROCESSED_DIR"
    
    if [ -z "$FILENAME" ]; then
      echo "Usage: $0 approve <filename>"
      echo "Available pending merges:"
      ls "$PENDING_DIR"
      exit 1
    fi
    
    # Handle if user passed full path or just filename
    BASENAME=$(basename "$FILENAME")
    SOURCE_FILE="$PENDING_DIR/$BASENAME"
    
    if [ -f "$SOURCE_FILE" ]; then
      mv "$SOURCE_FILE" "$PROCESSED_DIR/"
      echo "Marked $BASENAME as PROCESSED."
    else
      echo "Error: File $SOURCE_FILE not found."
    fi
    ;;

  question)
    SAVE_MODE=0
    QUESTION_TEXT=""
    
    # Parse args for this command
    while [[ $# -gt 0 ]]; do
      key="$1"
      case $key in
        --save|-s)
          SAVE_MODE=1
          shift
          ;;
        *)
          QUESTION_TEXT="$QUESTION_TEXT $1"
          shift
          ;;
      esac
    done
    
    # Trim leading space
    QUESTION_TEXT=$(echo "$QUESTION_TEXT" | sed 's/^[[:space:]]*//')
    
    if [ -z "$QUESTION_TEXT" ]; then
      echo "Usage: $0 question [--save] <your question>"
      exit 1
    fi
    
    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/question.md")
    # Include both DOMAINS and LESSONS in the context
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Question:" >> "$TMP_PROMPT"
    echo "$QUESTION_TEXT" >> "$TMP_PROMPT"
    
    echo "Thinking..."
    TMP_OUTPUT=$(mktemp)
    cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS > "$TMP_OUTPUT" 2>&1
    RESPONSE=$(cat "$TMP_OUTPUT")
    rm "$TMP_PROMPT" "$TMP_OUTPUT"

    if [ "$SAVE_MODE" -eq 1 ]; then
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        mkdir -p "$ANSWERS_DIR"
        OUT_FILE="$ANSWERS_DIR/A-$TIMESTAMP.md"
        
        echo "# Answer Record: A-$TIMESTAMP" > "$OUT_FILE"
        echo "**Date:** $(date)" >> "$OUT_FILE"
        echo "**Question:** $QUESTION_TEXT" >> "$OUT_FILE"
        echo "" >> "$OUT_FILE"
        echo "## Answer" >> "$OUT_FILE"
        echo "$RESPONSE" >> "$OUT_FILE"
        
        echo "Answer saved to: $OUT_FILE"
        echo "------------------------------------------------"
        cat "$OUT_FILE"
        echo "------------------------------------------------"
    else
        echo "$RESPONSE"
    fi
    ;;
    
  refresh)
    FILENAME="$1"
    
    if [ -z "$FILENAME" ]; then
        echo "Usage: $0 refresh <answer_file>"
        exit 1
    fi
    
    if [ ! -f "$FILENAME" ]; then
        echo "Error: File $FILENAME not found."
        exit 1
    fi
    
    # Extract Original Question
    ORIGINAL_QUESTION=$(grep "\*\*Question:\*\*" "$FILENAME" | cut -d ':' -f 2- | xargs)
    
    if [ -z "$ORIGINAL_QUESTION" ]; then
        echo "Error: Could not extract question from $FILENAME."
        exit 1
    fi
    
    echo "Re-running question: $ORIGINAL_QUESTION"
    
    # Re-run LLM
    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/question.md")
    # Include LESSONS here too
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Question:" >> "$TMP_PROMPT"
    echo "$ORIGINAL_QUESTION" >> "$TMP_PROMPT"
    
    echo "Thinking..."
    NEW_RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    # Create temp file with new content for diffing
    TMP_NEW=$(mktemp)
    sed '/## Answer/q' "$FILENAME" > "$TMP_NEW"
    echo "$NEW_RESPONSE" >> "$TMP_NEW"
    
    echo "Diff (Original vs New):"
    echo "------------------------------------------------"
    diff "$FILENAME" "$TMP_NEW"
    echo "------------------------------------------------"
    
    read -p "Accept new version? (y/n): " CONFIRM
    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
        mv "$TMP_NEW" "$FILENAME"
        echo "Updated $FILENAME."
    else
        echo "Kept original version."
        rm "$TMP_NEW"
    fi
    ;;

  garden)
    echo "================================================"
    echo "ðŸŒ¿ Knowledge Garden Audit"
    echo "================================================"
    
    echo ""
    echo "ðŸ‚ Stale Files (>60 days since update):"
    STALE_FILES=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -mtime +60 2>/dev/null)
    if [ -z "$STALE_FILES" ]; then
        echo "   (None - Good job!)"
    else
        echo "$STALE_FILES"
    fi

    echo ""
    echo "ðŸ•¸ï¸  Empty Files (0 bytes):"
    EMPTY_FILES=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -type f -empty 2>/dev/null)
    if [ -z "$EMPTY_FILES" ]; then
        echo "   (None)"
    else
        echo "$EMPTY_FILES"
    fi
    
    echo ""
    echo "ðŸ‘» Orphaned Files (Not referenced in parent index):"
    # Logic: Find leaf files, check if filename exists in parent index.md
    find "$DOMAINS_DIR" -name "*.md" ! -name "index.md" -print0 | while IFS= read -r -d '' file; do
        dir=$(dirname "$file")
        filename=$(basename "$file")
        index_file="$dir/index.md"

        # If index exists, check content
        if [ -f "$index_file" ]; then
            if ! grep -q "$filename" "$index_file"; then
                echo "   $file (missing from $(basename "$dir")/index.md)"
            fi
        fi
    done

    # Personal domain specific checks
    PERSONAL_DIR="$DOMAINS_DIR/personal"

    echo ""
    echo "ðŸ“‹ Stale Projects (Active but no updates in 14+ days):"
    FOUND_STALE=0
    for f in "$PERSONAL_DIR/projects"/*.md; do
        [ -f "$f" ] || continue
        [ "$(basename "$f")" = "index.md" ] && continue
        # Check if Active and old
        if grep -q "Status:\*\* Active" "$f" 2>/dev/null; then
            if [[ "$OSTYPE" == "darwin"* ]]; then
                if [ $(find "$f" -mtime +14 2>/dev/null | wc -l) -gt 0 ]; then
                    echo "   $f"
                    FOUND_STALE=1
                fi
            else
                if [ $(find "$f" -mtime +14 2>/dev/null | wc -l) -gt 0 ]; then
                    echo "   $f"
                    FOUND_STALE=1
                fi
            fi
        fi
    done
    [ $FOUND_STALE -eq 0 ] && echo "   (None)"

    echo ""
    echo "ðŸ¤” Decisions Awaiting Reflection:"
    FOUND_PENDING=0
    for f in "$PERSONAL_DIR/decisions"/D-*.md; do
        [ -f "$f" ] || continue
        if grep -q "Status:\*\* Active" "$f" 2>/dev/null; then
            DECISION=$(head -1 "$f" | sed 's/# Decision: //')
            echo "   $(basename "$f"): $DECISION"
            FOUND_PENDING=1
        fi
    done
    [ $FOUND_PENDING -eq 0 ] && echo "   (None - all decisions reflected upon)"

    echo ""
    echo "ðŸŽ¯ Unchecked Goals:"
    FOUND_GOALS=0
    if [ -f "$PERSONAL_DIR/profile/goals.md" ]; then
        UNCHECKED=$(grep -c "\- \[ \]" "$PERSONAL_DIR/profile/goals.md" 2>/dev/null) || UNCHECKED=0
        if [ "$UNCHECKED" -gt 0 ] 2>/dev/null; then
            echo "   $UNCHECKED unchecked goals in profile/goals.md"
            grep "\- \[ \]" "$PERSONAL_DIR/profile/goals.md" 2>/dev/null | head -5 | sed 's/^/   /'
            FOUND_GOALS=1
        fi
    fi
    for f in "$PERSONAL_DIR/projects"/*.md; do
        [ -f "$f" ] || continue
        [ "$(basename "$f")" = "index.md" ] && continue
        UNCHECKED=$(grep -c "\- \[ \]" "$f" 2>/dev/null) || UNCHECKED=0
        if [ "$UNCHECKED" -gt 0 ] 2>/dev/null; then
            echo "   $UNCHECKED unchecked goals in $(basename "$f")"
            FOUND_GOALS=1
        fi
    done
    [ $FOUND_GOALS -eq 0 ] && echo "   (None - all goals checked!)"

    echo "================================================"
    ;;

  challenge)
    USER_INPUT="$@"
    if [ -z "$USER_INPUT" ]; then
      echo "Usage: $0 challenge <proposal text | file path>"
      exit 1
    fi
    
    # Determine input type
    if [ -f "$USER_INPUT" ]; then
      echo "Reading proposal file..."
      PROPOSAL_CONTENT=$(cat "$USER_INPUT")
    else
      PROPOSAL_CONTENT="$USER_INPUT"
    fi

    PROMPT_TEMPLATE=$(cat "$PROMPTS_DIR/challenge.md")
    # Gather broad context
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    
    TMP_PROMPT=$(mktemp)
    echo "$PROMPT_TEMPLATE" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context (Knowledge Base):" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Proposal:" >> "$TMP_PROMPT"
    echo "$PROPOSAL_CONTENT" >> "$TMP_PROMPT"
    
    echo "âš”ï¸  Challenging your proposal..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"
    
    echo "------------------------------------------------"
    echo "$RESPONSE"
    echo "------------------------------------------------"
    ;;

  debate)
    QUESTION_TEXT="$@"
    if [ -z "$QUESTION_TEXT" ]; then
      echo "Usage: $0 [--claude|--kilo] debate <your question>"
      exit 1
    fi

    # Set model order based on flags
    if [ "$LLM_CMD" = "claude" ]; then
        MODEL_A="claude"
        MODEL_A_ARGS="--print --output-format text --allowedTools WebSearch,WebFetch"
        MODEL_A_NAME="Claude"
        MODEL_B="gemini"
        MODEL_B_ARGS=""
        MODEL_B_NAME="Gemini"
    elif [ "$LLM_CMD" = "kilocode" ]; then
        MODEL_A="kilocode"
        MODEL_A_ARGS="--auto --nosplash"
        MODEL_A_NAME="Kilocode"
        MODEL_B="claude"
        MODEL_B_ARGS="--print --output-format text --allowedTools WebSearch,WebFetch"
        MODEL_B_NAME="Claude"
    else
        MODEL_A="gemini"
        MODEL_A_ARGS=""
        MODEL_A_NAME="Gemini"
        MODEL_B="claude"
        MODEL_B_ARGS="--print --output-format text --allowedTools WebSearch,WebFetch"
        MODEL_B_NAME="Claude"
    fi

    # Load context once
    CONTEXT=$(find "$DOMAINS_DIR" "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    QUESTION_PROMPT=$(cat "$PROMPTS_DIR/question.md")
    CRITIQUE_PROMPT=$(cat "$PROMPTS_DIR/debate_critique.md")

    # === ROUND 1: Model A answers ===
    echo "================================================"
    echo "ROUND 1: $MODEL_A_NAME's Initial Answer"
    echo "================================================"

    TMP_PROMPT=$(mktemp)
    echo "$QUESTION_PROMPT" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Question:" >> "$TMP_PROMPT"
    echo "$QUESTION_TEXT" >> "$TMP_PROMPT"

    ANSWER_1=$(cat "$TMP_PROMPT" | $MODEL_A $MODEL_A_ARGS 2>&1)
    rm "$TMP_PROMPT"
    echo "$ANSWER_1"

    # === ROUND 2: Model B critiques & rewrites ===
    echo ""
    echo "================================================"
    echo "ROUND 2: $MODEL_B_NAME's Critique & Rewrite"
    echo "================================================"

    TMP_PROMPT=$(mktemp)
    echo "$CRITIQUE_PROMPT" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Original Question:" >> "$TMP_PROMPT"
    echo "$QUESTION_TEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Previous Answer:" >> "$TMP_PROMPT"
    echo "$ANSWER_1" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Knowledge Base Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"

    ANSWER_2=$(cat "$TMP_PROMPT" | $MODEL_B $MODEL_B_ARGS 2>&1)
    rm "$TMP_PROMPT"
    echo "$ANSWER_2"

    # === ROUND 3: Model A critiques & finalizes ===
    echo ""
    echo "================================================"
    echo "ROUND 3: $MODEL_A_NAME's Final Synthesis"
    echo "================================================"

    TMP_PROMPT=$(mktemp)
    echo "$CRITIQUE_PROMPT" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Original Question:" >> "$TMP_PROMPT"
    echo "$QUESTION_TEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Previous Answer:" >> "$TMP_PROMPT"
    echo "$ANSWER_2" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Knowledge Base Context:" >> "$TMP_PROMPT"
    echo "$CONTEXT" >> "$TMP_PROMPT"

    FINAL_ANSWER=$(cat "$TMP_PROMPT" | $MODEL_A $MODEL_A_ARGS 2>&1)
    rm "$TMP_PROMPT"
    echo "$FINAL_ANSWER"

    echo ""
    echo "================================================"
    echo "Debate Complete"
    echo "================================================"
    ;;

  project)
    PROJECTS_DIR="$DOMAINS_DIR/personal/projects"

    # Handle 'list' subcommand
    if [ "$1" = "list" ]; then
        echo "================================================"
        echo "Active Projects"
        echo "================================================"
        for f in "$PROJECTS_DIR"/*.md; do
            [ -f "$f" ] || continue
            [ "$(basename "$f")" = "index.md" ] && continue
            NAME=$(basename "$f" .md)
            STATUS=$(grep -m1 "^\*\*Status:\*\*" "$f" 2>/dev/null | cut -d':' -f2 | xargs)
            echo "- $NAME: ${STATUS:-Unknown}"
        done
        exit 0
    fi

    PROJECT_NAME="$1"
    shift

    if [ -z "$PROJECT_NAME" ]; then
        echo "Usage: $0 project <name> [note]"
        echo "       $0 project <name> --goal <goal>"
        echo "       $0 project <name> --blocker <blocker>"
        echo "       $0 project list"
        exit 1
    fi

    # Sanitize project name for filename
    PROJECT_SLUG=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '_' | tr -cd '[:alnum:]_')
    PROJECT_FILE="$PROJECTS_DIR/${PROJECT_SLUG}.md"

    # Parse subcommands
    UPDATE_TYPE="note"
    UPDATE_CONTENT=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --goal)
                UPDATE_TYPE="goal"
                shift
                UPDATE_CONTENT="$*"
                break
                ;;
            --blocker)
                UPDATE_TYPE="blocker"
                shift
                UPDATE_CONTENT="$*"
                break
                ;;
            *)
                UPDATE_CONTENT="$UPDATE_CONTENT $1"
                shift
                ;;
        esac
    done
    UPDATE_CONTENT=$(echo "$UPDATE_CONTENT" | xargs)

    if [ -z "$UPDATE_CONTENT" ]; then
        echo "Error: No content provided for project update."
        exit 1
    fi

    TODAY=$(date +%Y-%m-%d)

    # Create new project file if it doesn't exist
    if [ ! -f "$PROJECT_FILE" ]; then
        echo "Creating new project: $PROJECT_NAME"
        cat > "$PROJECT_FILE" << EOF
# Project: $PROJECT_NAME
**Status:** Active
**Started:** $TODAY
**Target:** TBD

## Goals
*No goals yet*

## Milestones
*No milestones yet*

## Current Blockers
*No blockers*

## Notes
EOF
        # Update index
        echo "- [$PROJECT_NAME](${PROJECT_SLUG}.md): Active project" >> "$PROJECTS_DIR/index.md"
    fi

    # Append update based on type
    case "$UPDATE_TYPE" in
        goal)
            # Add to Goals section
            sed -i '' "s/\*No goals yet\*//" "$PROJECT_FILE" 2>/dev/null || sed -i "s/\*No goals yet\*//" "$PROJECT_FILE"
            # Find Goals section and append
            awk -v goal="- [ ] $UPDATE_CONTENT *(Added: $TODAY)*" '
                /^## Goals/ { print; getline; print goal; next }
                { print }
            ' "$PROJECT_FILE" > "${PROJECT_FILE}.tmp" && mv "${PROJECT_FILE}.tmp" "$PROJECT_FILE"
            echo "Added goal to $PROJECT_NAME: $UPDATE_CONTENT"
            ;;
        blocker)
            # Add to Blockers section
            sed -i '' "s/\*No blockers\*//" "$PROJECT_FILE" 2>/dev/null || sed -i "s/\*No blockers\*//" "$PROJECT_FILE"
            awk -v blocker="- $UPDATE_CONTENT *(Added: $TODAY)*" '
                /^## Current Blockers/ { print; getline; print blocker; next }
                { print }
            ' "$PROJECT_FILE" > "${PROJECT_FILE}.tmp" && mv "${PROJECT_FILE}.tmp" "$PROJECT_FILE"
            echo "Added blocker to $PROJECT_NAME: $UPDATE_CONTENT"
            ;;
        note)
            # Append to Notes section
            echo "" >> "$PROJECT_FILE"
            echo "### $TODAY" >> "$PROJECT_FILE"
            echo "$UPDATE_CONTENT" >> "$PROJECT_FILE"
            echo "Added note to $PROJECT_NAME"
            ;;
    esac

    echo "------------------------------------------------"
    tail -20 "$PROJECT_FILE"
    echo "------------------------------------------------"
    ;;

  interest)
    INTERESTS_DIR="$DOMAINS_DIR/personal/interests"

    # Handle 'list' subcommand
    if [ "$1" = "list" ]; then
        echo "================================================"
        echo "Interests"
        echo "================================================"
        for f in "$INTERESTS_DIR"/*.md; do
            [ -f "$f" ] || continue
            [ "$(basename "$f")" = "index.md" ] && continue
            NAME=$(basename "$f" .md | tr '_' ' ')
            echo "- $NAME"
        done
        exit 0
    fi

    TOPIC_NAME="$1"
    shift

    if [ -z "$TOPIC_NAME" ]; then
        echo "Usage: $0 interest <topic> [note]"
        echo "       $0 interest <topic> --resource <url or description>"
        echo "       $0 interest list"
        exit 1
    fi

    # Sanitize topic name for filename
    TOPIC_SLUG=$(echo "$TOPIC_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '_' | tr -cd '[:alnum:]_')
    TOPIC_FILE="$INTERESTS_DIR/${TOPIC_SLUG}.md"

    # Parse subcommands
    UPDATE_TYPE="note"
    UPDATE_CONTENT=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --resource)
                UPDATE_TYPE="resource"
                shift
                UPDATE_CONTENT="$*"
                break
                ;;
            *)
                UPDATE_CONTENT="$UPDATE_CONTENT $1"
                shift
                ;;
        esac
    done
    UPDATE_CONTENT=$(echo "$UPDATE_CONTENT" | xargs)

    if [ -z "$UPDATE_CONTENT" ]; then
        echo "Error: No content provided for interest update."
        exit 1
    fi

    TODAY=$(date +%Y-%m-%d)

    # Create new interest file if it doesn't exist
    if [ ! -f "$TOPIC_FILE" ]; then
        echo "Creating new interest: $TOPIC_NAME"
        cat > "$TOPIC_FILE" << EOF
# Interest: $TOPIC_NAME
**Started Exploring:** $TODAY

## Why This Interests Me
*TBD*

## Key Resources
*No resources yet*

## Insights
*No insights yet*

## Notes
EOF
        # Update index
        echo "- [$TOPIC_NAME](${TOPIC_SLUG}.md): Area of interest" >> "$INTERESTS_DIR/index.md"
    fi

    # Append update based on type
    case "$UPDATE_TYPE" in
        resource)
            sed -i '' "s/\*No resources yet\*//" "$TOPIC_FILE" 2>/dev/null || sed -i "s/\*No resources yet\*//" "$TOPIC_FILE"
            awk -v resource="- $UPDATE_CONTENT *(Added: $TODAY)*" '
                /^## Key Resources/ { print; getline; print resource; next }
                { print }
            ' "$TOPIC_FILE" > "${TOPIC_FILE}.tmp" && mv "${TOPIC_FILE}.tmp" "$TOPIC_FILE"
            echo "Added resource to $TOPIC_NAME: $UPDATE_CONTENT"
            ;;
        note)
            echo "" >> "$TOPIC_FILE"
            echo "### $TODAY" >> "$TOPIC_FILE"
            echo "$UPDATE_CONTENT" >> "$TOPIC_FILE"
            echo "Added note to $TOPIC_NAME"
            ;;
    esac

    echo "------------------------------------------------"
    tail -15 "$TOPIC_FILE"
    echo "------------------------------------------------"
    ;;

  profile)
    PROFILE_DIR="$DOMAINS_DIR/personal/profile"

    SUBCOMMAND="$1"
    shift
    UPDATE_CONTENT="$*"

    if [ -z "$SUBCOMMAND" ]; then
        echo "Usage: $0 profile skill <skill description>"
        echo "       $0 profile experience <experience description>"
        echo "       $0 profile goal <goal description>"
        echo "       $0 profile show"
        exit 1
    fi

    TODAY=$(date +%Y-%m-%d)

    case "$SUBCOMMAND" in
        show)
            echo "================================================"
            echo "Profile Overview"
            echo "================================================"
            echo ""
            echo "=== Skills ==="
            cat "$PROFILE_DIR/skills.md" 2>/dev/null | grep -v "^#" | grep -v "^\*\*Last" | head -20
            echo ""
            echo "=== Goals ==="
            cat "$PROFILE_DIR/goals.md" 2>/dev/null | grep -v "^#" | grep -v "^\*\*Last" | head -20
            exit 0
            ;;
        skill)
            if [ -z "$UPDATE_CONTENT" ]; then
                echo "Error: No skill description provided."
                exit 1
            fi
            SKILLS_FILE="$PROFILE_DIR/skills.md"
            # Add skill to Technical Skills section
            sed -i '' "s/\*Add skills with proficiency level.*\*//" "$SKILLS_FILE" 2>/dev/null || sed -i "s/\*Add skills with proficiency level.*\*//" "$SKILLS_FILE"
            awk -v skill="- $UPDATE_CONTENT" '
                /^## Technical Skills/ { print; getline; print skill; next }
                { print }
            ' "$SKILLS_FILE" > "${SKILLS_FILE}.tmp" && mv "${SKILLS_FILE}.tmp" "$SKILLS_FILE"
            # Update timestamp
            sed -i '' "s/\*\*Last Updated:\*\*.*/\*\*Last Updated:\*\* $TODAY/" "$SKILLS_FILE" 2>/dev/null || sed -i "s/\*\*Last Updated:\*\*.*/\*\*Last Updated:\*\* $TODAY/" "$SKILLS_FILE"
            echo "Added skill: $UPDATE_CONTENT"
            ;;
        experience)
            if [ -z "$UPDATE_CONTENT" ]; then
                echo "Error: No experience description provided."
                exit 1
            fi
            EXP_FILE="$PROFILE_DIR/experience.md"
            sed -i '' "s/\*Add current position.*\*//" "$EXP_FILE" 2>/dev/null || sed -i "s/\*Add current position.*\*//" "$EXP_FILE"
            awk -v exp="- $UPDATE_CONTENT *(Added: $TODAY)*" '
                /^## Key Accomplishments/ { print; getline; print exp; next }
                { print }
            ' "$EXP_FILE" > "${EXP_FILE}.tmp" && mv "${EXP_FILE}.tmp" "$EXP_FILE"
            sed -i '' "s/\*\*Last Updated:\*\*.*/\*\*Last Updated:\*\* $TODAY/" "$EXP_FILE" 2>/dev/null || sed -i "s/\*\*Last Updated:\*\*.*/\*\*Last Updated:\*\* $TODAY/" "$EXP_FILE"
            echo "Added experience: $UPDATE_CONTENT"
            ;;
        goal)
            if [ -z "$UPDATE_CONTENT" ]; then
                echo "Error: No goal description provided."
                exit 1
            fi
            GOALS_FILE="$PROFILE_DIR/goals.md"
            sed -i '' "s/\*Add immediate priorities.*\*//" "$GOALS_FILE" 2>/dev/null || sed -i "s/\*Add immediate priorities.*\*//" "$GOALS_FILE"
            awk -v goal="- [ ] $UPDATE_CONTENT *(Added: $TODAY)*" '
                /^## Short-Term Goals/ { print; getline; print goal; next }
                { print }
            ' "$GOALS_FILE" > "${GOALS_FILE}.tmp" && mv "${GOALS_FILE}.tmp" "$GOALS_FILE"
            sed -i '' "s/\*\*Last Updated:\*\*.*/\*\*Last Updated:\*\* $TODAY/" "$GOALS_FILE" 2>/dev/null || sed -i "s/\*\*Last Updated:\*\*.*/\*\*Last Updated:\*\* $TODAY/" "$GOALS_FILE"
            echo "Added goal: $UPDATE_CONTENT"
            ;;
        *)
            echo "Unknown profile subcommand: $SUBCOMMAND"
            echo "Use: skill, experience, goal, or show"
            exit 1
            ;;
    esac
    ;;

  decide)
    DECISIONS_DIR="$DOMAINS_DIR/personal/decisions"

    # Handle 'reflect' subcommand
    if [ "$1" = "reflect" ]; then
        DECISION_FILE="$2"
        if [ -z "$DECISION_FILE" ]; then
            echo "Usage: $0 decide reflect <decision-file>"
            echo "Available decisions:"
            ls "$DECISIONS_DIR"/*.md 2>/dev/null | grep -v index.md | xargs -I {} basename {}
            exit 1
        fi

        # Find the file
        if [ ! -f "$DECISIONS_DIR/$DECISION_FILE" ]; then
            DECISION_FILE="${DECISION_FILE}.md"
        fi
        if [ ! -f "$DECISIONS_DIR/$DECISION_FILE" ]; then
            echo "Error: Decision file not found: $DECISION_FILE"
            exit 1
        fi

        echo "Opening reflection for: $DECISION_FILE"
        echo "Current decision:"
        echo "------------------------------------------------"
        cat "$DECISIONS_DIR/$DECISION_FILE"
        echo "------------------------------------------------"
        echo ""
        echo "Enter your reflection (what happened, lessons learned):"
        read -r REFLECTION

        TODAY=$(date +%Y-%m-%d)
        cat >> "$DECISIONS_DIR/$DECISION_FILE" << EOF

## Reflection
**Date:** $TODAY

$REFLECTION
EOF
        # Update status
        sed -i '' "s/\*\*Status:\*\* Active/\*\*Status:\*\* Reflected/" "$DECISIONS_DIR/$DECISION_FILE" 2>/dev/null || sed -i "s/\*\*Status:\*\* Active/\*\*Status:\*\* Reflected/" "$DECISIONS_DIR/$DECISION_FILE"
        echo "Reflection added to $DECISION_FILE"
        exit 0
    fi

    # Handle 'list' subcommand
    if [ "$1" = "list" ]; then
        echo "================================================"
        echo "Decisions"
        echo "================================================"
        for f in "$DECISIONS_DIR"/D-*.md; do
            [ -f "$f" ] || continue
            NAME=$(head -1 "$f" | sed 's/# Decision: //')
            STATUS=$(grep -m1 "^\*\*Status:\*\*" "$f" 2>/dev/null | cut -d':' -f2 | xargs)
            DATE=$(grep -m1 "^\*\*Date:\*\*" "$f" 2>/dev/null | cut -d':' -f2 | xargs)
            echo "- [$DATE] $NAME ($STATUS)"
        done
        exit 0
    fi

    # New decision
    DECISION_TEXT=""
    CONTEXT=""
    EXPECTED=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --context)
                shift
                CONTEXT="$1"
                shift
                ;;
            --expected)
                shift
                EXPECTED="$1"
                shift
                ;;
            *)
                DECISION_TEXT="$DECISION_TEXT $1"
                shift
                ;;
        esac
    done
    DECISION_TEXT=$(echo "$DECISION_TEXT" | xargs)

    if [ -z "$DECISION_TEXT" ]; then
        echo "Usage: $0 decide <decision statement> [--context <why>] [--expected <outcome>]"
        echo "       $0 decide reflect <decision-file>"
        echo "       $0 decide list"
        exit 1
    fi

    TODAY=$(date +%Y-%m-%d)
    # Create slug from decision text
    SLUG=$(echo "$DECISION_TEXT" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-' | cut -c1-30)
    DECISION_FILE="$DECISIONS_DIR/D-${TODAY}-${SLUG}.md"

    cat > "$DECISION_FILE" << EOF
# Decision: $DECISION_TEXT
**Date:** $TODAY
**Domain:** General
**Status:** Active

## Context
${CONTEXT:-*Context not provided*}

## Options Considered
*Not documented*

## Decision
$DECISION_TEXT

## Expected Outcome
${EXPECTED:-*Expected outcome not specified*}

## Reflection
*To be added later with: ./cli/know decide reflect $(basename "$DECISION_FILE")*
EOF

    # Update index
    echo "- [$(basename "$DECISION_FILE")]($(basename "$DECISION_FILE")): $DECISION_TEXT" >> "$DECISIONS_DIR/index.md"

    echo "Decision recorded: $DECISION_FILE"
    echo "------------------------------------------------"
    cat "$DECISION_FILE"
    echo "------------------------------------------------"
    ;;

  review)
    REVIEW_TYPE="week"
    PROJECT_FILTER=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --month)
                REVIEW_TYPE="month"
                shift
                ;;
            --project)
                shift
                PROJECT_FILTER="$1"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    echo "================================================"
    if [ -n "$PROJECT_FILTER" ]; then
        echo "Project Review: $PROJECT_FILTER"
    elif [ "$REVIEW_TYPE" = "month" ]; then
        echo "Monthly Review"
    else
        echo "Weekly Review"
    fi
    echo "================================================"

    # Determine date range
    if [ "$REVIEW_TYPE" = "month" ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            SINCE_DATE=$(date -v-30d +%Y-%m-%d)
        else
            SINCE_DATE=$(date -d "30 days ago" +%Y-%m-%d)
        fi
        PERIOD="last 30 days"
    else
        if [[ "$OSTYPE" == "darwin"* ]]; then
            SINCE_DATE=$(date -v-7d +%Y-%m-%d)
        else
            SINCE_DATE=$(date -d "7 days ago" +%Y-%m-%d)
        fi
        PERIOD="last 7 days"
    fi

    # Gather context
    REVIEW_PROMPT=$(cat "$PROMPTS_DIR/review.md")

    # Get recent register archives
    RECENT_CAPTURES=""
    for f in outputs/register_archive/*.md; do
        [ -f "$f" ] || continue
        FILE_DATE=$(basename "$f" | grep -o '[0-9]\{8\}' | head -1)
        if [ -n "$FILE_DATE" ]; then
            FILE_DATE_FMT="${FILE_DATE:0:4}-${FILE_DATE:4:2}-${FILE_DATE:6:2}"
            if [[ "$FILE_DATE_FMT" > "$SINCE_DATE" ]] || [[ "$FILE_DATE_FMT" == "$SINCE_DATE" ]]; then
                RECENT_CAPTURES="$RECENT_CAPTURES
--- $(basename "$f") ---
$(cat "$f")"
            fi
        fi
    done

    # Get project context
    if [ -n "$PROJECT_FILTER" ]; then
        PROJECT_SLUG=$(echo "$PROJECT_FILTER" | tr '[:upper:]' '[:lower:]' | tr ' ' '_' | tr -cd '[:alnum:]_')
        PROJECT_CONTEXT=$(cat "$DOMAINS_DIR/personal/projects/${PROJECT_SLUG}.md" 2>/dev/null)
    else
        PROJECT_CONTEXT=$(cat "$DOMAINS_DIR/personal/projects"/*.md 2>/dev/null | head -200)
    fi

    # Get recent decisions
    DECISIONS_CONTEXT=$(cat "$DOMAINS_DIR/personal/decisions"/D-*.md 2>/dev/null | head -100)

    # Get profile context
    PROFILE_CONTEXT=$(cat "$DOMAINS_DIR/personal/profile"/*.md 2>/dev/null)

    # Build prompt
    TMP_PROMPT=$(mktemp)
    echo "$REVIEW_PROMPT" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "Review Period: $PERIOD (since $SINCE_DATE)" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Recent Captures ===" >> "$TMP_PROMPT"
    echo "$RECENT_CAPTURES" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Projects ===" >> "$TMP_PROMPT"
    echo "$PROJECT_CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Decisions ===" >> "$TMP_PROMPT"
    echo "$DECISIONS_CONTEXT" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Profile (Goals) ===" >> "$TMP_PROMPT"
    echo "$PROFILE_CONTEXT" >> "$TMP_PROMPT"

    echo "Generating review..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"

    echo ""
    echo "$RESPONSE"
    echo ""
    echo "================================================"
    ;;

  connect)
    QUERY="$*"

    if [ -z "$QUERY" ]; then
        echo "Usage: $0 connect <question about connections>"
        echo "Example: $0 connect \"How does my interest in AI relate to the product roadmap?\""
        exit 1
    fi

    echo "================================================"
    echo "Finding Connections"
    echo "================================================"
    echo "Query: $QUERY"
    echo ""

    CONNECT_PROMPT=$(cat "$PROMPTS_DIR/connect.md")

    # Gather ALL context for connection analysis
    ALL_DOMAINS=$(find "$DOMAINS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    LESSONS_CONTEXT=$(find "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)

    TMP_PROMPT=$(mktemp)
    echo "$CONNECT_PROMPT" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "User Question: $QUERY" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Knowledge Base Content ===" >> "$TMP_PROMPT"
    echo "$ALL_DOMAINS" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Lessons ===" >> "$TMP_PROMPT"
    echo "$LESSONS_CONTEXT" >> "$TMP_PROMPT"

    echo "Analyzing connections..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"

    echo ""
    echo "$RESPONSE"
    echo ""
    echo "================================================"
    ;;

  prep)
    PERSON=""
    TOPIC=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --topic)
                shift
                TOPIC="$1"
                shift
                ;;
            *)
                if [ -z "$PERSON" ]; then
                    PERSON="$1"
                else
                    TOPIC="$1"
                fi
                shift
                ;;
        esac
    done

    if [ -z "$PERSON" ] && [ -z "$TOPIC" ]; then
        echo "Usage: $0 prep <person> [topic]"
        echo "       $0 prep --topic <topic>"
        echo "Example: $0 prep \"John Smith\" \"Q1 Planning\""
        echo "         $0 prep --topic \"Pricing strategy\""
        exit 1
    fi

    echo "================================================"
    if [ -n "$PERSON" ] && [ -n "$TOPIC" ]; then
        echo "Meeting Prep: $PERSON - $TOPIC"
    elif [ -n "$PERSON" ]; then
        echo "Meeting Prep: $PERSON"
    else
        echo "Topic Briefing: $TOPIC"
    fi
    echo "================================================"

    PREP_PROMPT=$(cat "$PROMPTS_DIR/prep.md")

    # Gather relevant context
    ALL_DOMAINS=$(find "$DOMAINS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)
    LESSONS_CONTEXT=$(find "$LESSONS_DIR" -name "*.md" -exec cat {} + 2>/dev/null)

    TMP_PROMPT=$(mktemp)
    echo "$PREP_PROMPT" > "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    if [ -n "$PERSON" ]; then
        echo "Person: $PERSON" >> "$TMP_PROMPT"
    fi
    if [ -n "$TOPIC" ]; then
        echo "Topic: $TOPIC" >> "$TMP_PROMPT"
    fi
    echo "" >> "$TMP_PROMPT"
    echo "=== Knowledge Base Content ===" >> "$TMP_PROMPT"
    echo "$ALL_DOMAINS" >> "$TMP_PROMPT"
    echo "" >> "$TMP_PROMPT"
    echo "=== Lessons ===" >> "$TMP_PROMPT"
    echo "$LESSONS_CONTEXT" >> "$TMP_PROMPT"

    echo "Generating briefing..."
    RESPONSE=$(cat "$TMP_PROMPT" | $LLM_CMD $LLM_ARGS 2>&1)
    rm "$TMP_PROMPT"

    echo ""
    echo "$RESPONSE"
    echo ""
    echo "================================================"
    ;;

  *)
    echo "Usage: $0 [--claude|--kilo] {capture|classify|question|learn|refresh|garden|challenge|debate|project|interest|profile|decide|review|connect|prep} [arguments]"
    echo "Options:"
    echo "  --claude    Use Claude instead of Gemini (default), with web search enabled"
    echo "  --kilo      Use Kilocode instead of Gemini"
    exit 1
    ;;
esac